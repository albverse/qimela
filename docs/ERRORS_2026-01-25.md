# 错误合计与复盘（2026-01-25）

> 目标：把今天这一串报错“**症状 → 根因 → 修复 → 预防**”一次性钉死，避免同类问题反复耗时。  
> 说明：部分报错来自你在拆分 Player/Chain/Health/UI/Flower 期间的中间态代码；这里按“最常见根因”归类总结。

---

## 1) GDScript 语法类（编译期直接报错）

### 1.1 `Unexpected "?" in source`（三目运算符写法错误）
**症状**  
`var jump_pressed := cond ? A : B` 报错。

**根因**  
Godot 的 GDScript 不支持 `?:`，只支持 Python 风格：
`truthy if condition else falsy`

**修复**  
把所有 `cond ? A : B` 改为：  
`var x = A if cond else B`

**预防**  
把“输入读取”封装成函数，避免每行都写条件表达式。

---

### 1.2 `Unexpected "Indent" in class body`
**症状**  
`if right and not left:` 报 “Unexpected Indent”。

**根因**  
这段代码**不在任何函数体内部**（缩进层级错了），GDScript 的类体不能直接写 `if`。

**修复**  
把逻辑移进明确函数（通常是 `tick()` / `_physics_process()` / `_process()` 之一），并确保缩进一致。

**预防**  
每次粘贴代码后，第一件事：看它是不是在 `func xxx():` 下面。

---

## 2) 类型推断/Variant 警告（你这里被当成 error）

> 你工程当前是“Warning treated as error”的风格，所以“推断成 Variant”的警告会直接中断运行。

### 2.1 `Cannot infer the type of "n"/"collider" variable ...`
**症状**  
- `var n := player.chimera_scene.instantiate()`  
- `var collider := hit_block["collider"]`  
报 “Cannot infer type”。

**根因**  
`instantiate()`、Dictionary 下标等返回 **Variant**，`:=` 触发“强类型推断”，但推不出来就直接失败。

**修复（推荐固定写法）**
- `PackedScene.instantiate()`：  
  `var n: Node = (player.chimera_scene as PackedScene).instantiate()`  
  需要 Node2D：  
  `var n2d: Node2D = (player.chimera_scene as PackedScene).instantiate() as Node2D`
- Dictionary：  
  `var collider_obj: Object = hit_block.get("collider")`  
  `var collider_node: Node = collider_obj as Node`

**预防**  
凡是从 `call()`、`Dictionary[]`、`instantiate()` 来的值：**不要用 `:=`**，要么显式类型，要么显式 `as`/`int()`。

---

### 2.2 `The variable type is being inferred from a Variant value ...`
**症状**  
`var ret := mb.call("on_chain_hit", player, i)` 或  
`var idx := 5 if emitting else clamp(energy, 0, 5)` 报 Variant 推断警告。

**根因**  
- `call()` 永远是 Variant  
- `clamp()` 可能按 Variant/float 路径走（尤其 energy 不是严格 int）

**修复**
- `call()`：  
  `var ret: int = int(mb.call("on_chain_hit", player, i))`
- `clamp()`：用 `clampi`（int 版）  
  `var idx: int = 5 if emitting else clampi(energy, 0, 5)`

**预防**  
能用 `clampi/clampf` 就不要用 `clamp`。  
跨脚本回调统一约定返回类型（例如 `on_chain_hit` 必须返回 int）。

---

## 3) 空引用/节点路径类（运行期炸）

### 3.1 `Invalid access to property ... on a base object of type 'Nil'`
**症状**  
`_player.get_node_or_null(_player.visual_path)` 报 `_player` 为 Nil。

**根因**  
拆分组件后，组件脚本的 `_player` 没有在使用前完成赋值（setup 顺序/生命周期问题）。

**修复（两种稳定解）**
1) **强制 setup 流程**（推荐）  
组件脚本提供 `setup(player: Player)`，由 Player 在 `_ready()` 里按顺序调用。  
同时组件内部任何使用 `_player` 的地方先 `if _player == null: return`。
2) **改为 onready 抓父节点**（只在父节点结构稳定时用）  
`@onready var _player: Player = get_parent() as Player`  
但一旦节点层级变化就会崩，所以不如 setup 稳。

**预防**  
组件化后：**禁止在 `_init()` 里做 get_node**；尽量在 `_ready()` 或 `setup()` 里做，并加 null guard。

---

### 3.2 `Found invalid node path 'Glow' on node 'LightningFlower'`
**症状**  
Flower 脚本里 `get_node("Glow")` 报路径不存在。

**根因**  
- 场景里节点名不是 Glow  
- 或脚本写死路径，但场景后来改了结构

**修复**
- 把 Glow 改为 **@export_node_path**（或直接拖拽节点引用）  
- 并且用 `get_node_or_null()` + 明确报错：  
  找不到就 push_error 并停用 glow 相关逻辑。

**预防**  
凡是跨节点引用：优先 export NodePath + Inspector 指定；不要写死字符串路径。

---

## 4) UI/Control 类差异（Godot 4.5 细节）

### 4.1 `TextureRect` 没有 `region_enabled`
**症状**  
`full.region_enabled = true` 报 “Invalid assignment ... TextureRect”。

**根因**  
`region_enabled` 是 Sprite2D/AtlasTexture 等相关概念，不是 TextureRect 的属性。

**修复（你现在这套正确方向）**  
用 **父 Control 的 `clip_contents` 裁剪** + 调整子 TextureRect 的 size/position 做“充能条”效果。

**预防**  
遇到“属性不存在”要先去官方文档确认该节点类型是否支持该属性。

---

### 4.2 爱心 full/empty 明明同尺寸却对不齐
**症状**  
两张图 size 一样，但叠放后视觉错位。

**根因（最常见）**  
- TextureRect 的 `stretch_mode/expand_mode` 不一致  
- 或 anchors/offset 没归零（Control 的布局问题）  
- 透明边界一致 ≠ 内容像素重心一致，叠放需要**统一对齐规则**

**修复（稳定做法）**
- 两个 TextureRect：anchors 全部设为同一套（通常左上 0,0），offset 归零  
- `stretch_mode = STRETCH_KEEP_ASPECT_CENTERED`（或你当前项目统一的一种）  
- 父容器用固定 `custom_minimum_size`，保证计算一致

**预防**  
UI 叠图：先锁布局（anchors/offset），再谈贴图内容。

---

## 5) 节点树时序/Deferred

### 5.1 `_ready(): add_child() failed ... blocked > 0`
**症状**  
`player_health.gd:36 @ _ready()` add_child 失败。

**根因**  
父节点还在 build 子树阶段（Godot 在某些时序下会阻止立即 add_child）。

**修复**  
`add_child.call_deferred(child)` 或把 UI 构建放到 `_enter_tree()`/延后一帧。

**预防**  
“在 _ready 里动态加复杂 UI”时，默认用 `call_deferred`。

---

## 6) 物理查询 API 变更（Godot 4.5）

### 6.1 `PhysicsPointQueryParameters2D.margin` 不存在
**症状**  
`pq.margin = 1.0` 报属性不存在。

**根因**  
PointQuery 参数里没有 margin 这个属性（Godot 4.x 的 API 差异）。

**修复**  
需要“点附近的容差/半径”时：  
用 `PhysicsShapeQueryParameters2D` + CircleShape2D（shape query 支持 margin/半径语义），或者直接调大 Circle 半径。

**预防**  
查询参数（Point/Ray/Shape）三种类别不要混用属性；不确定就查官方文档。

---

## 7) RID/CollisionObject 使用边界

### 7.1 `Function "get_rid()" not found in base self`
**症状**  
在 `extends Node` 的脚本里调用 `self.get_rid()` 报错。

**根因**  
`get_rid()` 是 `Object` 的通用函数，但在 GDScript 某些节点类型上需要是 `CollisionObject2D` 才有你期望的 RID 用法（尤其用于 physics exclude）。

**修复**
- 排除玩家时，拿 **玩家的 CollisionObject2D**：  
  `c.ray_q.exclude = [(player as CollisionObject2D).get_rid()]`  
  前提：Player 确实是 CharacterBody2D/CollisionObject2D。

**预防**  
“物理 exclude 用 RID”只能来自 CollisionObject2D（Body/Area）。

---

## 8) 反射调用/方法名不一致

### 8.1 `Nonexistent function 'handle_unhandled_input (via call)'`
**症状**  
`_chain.call("handle_unhandled_input", event)` 报函数不存在。

**根因**  
- 方法名改了/拼写不一致  
- 或脚本未 reload 到最新（类名/文件路径变动后常见）

**修复**
- 最稳：不要反射 call，直接强类型调用：  
  `_chain.handle_unhandled_input(event)`  
- 或确保脚本里确实定义了：  
  `func handle_unhandled_input(event: InputEvent) -> void:`

**预防**  
反射 call 只在“可选接口”时用；核心路径都用直接调用。

---

## 9) 逻辑类（不是报错但会让表现“怪”）

### 9.1 锁链外观/溶解/物理动效“变成新版本”
**根因模板**
- 代码在初始化时重置了 Line2D 的 width/texture/gradient/material  
- 或复用了同一份 ShaderMaterial 导致“串台”  
- 或每次发射重建 points 数量/顺序导致 anchor 反转

**修复要点**
- 初始化 Line2D 时只做：`visible=false; material=null; modulate=WHITE`  
  **不要**碰 inspector 里设定的 width/texture/gradient  
- 每条链各自持有 ShaderMaterial（不要共享同一个）  
- points 数量固定且只在 rope_segments 改变时重建

**预防**  
“复刻旧表现”时，明确：哪些属性归 Inspector，哪些属性归脚本。脚本只写必要最小集。

---

### 9.2 “两根链打中飞怪，飞怪恢复移动后链被拖着走”
**根因模板**
- 怪物恢复时没有通知链系统 dissolve/detach  
- 或只支持单链 slot，第二条链状态无人管理

**修复要点**
- MonsterBase 记录 `_linked_slots: Array[int]`  
- 恢复时对每个 slot 回调 `force_dissolve_chain(slot)`（先缓存 player 引用再置空，防 null call）

**预防**  
凡是“多链同时作用”——必须从数据结构上支持多 slot，而不是打补丁。

---

## 10) 碰撞层/Mask 误会（最容易浪费时间的坑）

### 10.1 “我勾了 1 与 4，为什么效果不对？”
**根因**  
脚本里的 `collision_mask: int` 是 **bitmask**。  
Layer(1)=1，Layer(2)=2，Layer(3)=4，Layer(4)=8……不是“写 4 就是第4层”。

**修复**
- 用 Godot 4.5 的导出标注，让 Inspector 直接勾选层：  
  `@export_flags_2d_physics var chain_hit_mask: int = 0` citeturn0search4  
- 或手算：`mask = (1 << (layer-1))` citeturn0search3

**预防**  
凡是 mask/layer 变量，一律用 `@export_flags_2d_physics`，禁止纯数字硬填。

---

## 今日结论（防再犯的“硬规矩”）
1) Variant 来源（call/Dictionary/instantiate）一律显式类型或显式 cast。  
2) 碰撞层一律用 `@export_flags_2d_physics`，禁止用户手填数字。  
3) NodePath 一律 export + `get_node_or_null` + 明确报错。  
4) UI 动态 add_child 默认 call_deferred。  
5) 复刻旧表现：脚本不得改 Inspector 负责的视觉参数。  

